{"ast":null,"code":"import { Children, Component } from 'react';\nimport Vibrant from 'node-vibrant';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}; // This component takes a src prop (image source, can be a blob or an image path) or intercepts it's children to get the image element,\n// and parses the image using node-vibrant, and finally invokes the prop callback with an array of colors.\n\n\nvar ColorExtractor = function (_React$Component) {\n  inherits(ColorExtractor, _React$Component);\n\n  function ColorExtractor() {\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ColorExtractor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.processImage = function () {\n      if (_this.props.children) {\n        // If the image element is direct children of ColorExtractor component, intercept the children and use the `src` property\n        // $FlowFixMe\n        if (_this.props.children.props.src) {\n          _this.parseImage(_this.props.children.props.src, _this.props);\n        }\n      } else if (_this.props.src && typeof _this.props.src === 'string' && _this.props.src.length > 0) {\n        // if the image is provided via src prop\n        _this.parseImage(_this.props.src, _this.props);\n      } else {\n        console.error(\"Please provide an image url using the 'src' prop or wrap an image element under the <ColorExtractor /> component. Check out the docs for more info - https://goo.gl/rMZ5L7\");\n      }\n    }, _this.parseImage = function (image, props) {\n      Vibrant.from(image).maxColorCount(props.maxColors).getSwatches().then(function (swatches) {\n        return props.getColors(_this.getColorsFromSwatches(swatches, props));\n      }).catch(function (error) {\n        if (error) {\n          // This error is mainly due to CORS issue. So we retry again by using the default image class. But if still there is any error, we bail out!\n          _this.useDefaultImageClass(image, props);\n        }\n      });\n    }, _this.useDefaultImageClass = function (image, props) {\n      // If there is any CORS issue, then the default class recreates the image element with crossOrigin set to anonymous.\n      new Vibrant.DefaultOpts.ImageClass() // $FlowFixMe\n      .load(image.src).then(function (data) {\n        if (data.image) {\n          Vibrant.from(data.image).getSwatches().then(function (swatches) {\n            return props.getColors(_this.getColorsFromSwatches(swatches, props));\n          }).catch(function (error) {\n            if (error) {\n              props.onError(error);\n            }\n          });\n        }\n      }).catch(function (error) {\n        if (error) {\n          props.onError(error);\n        }\n      });\n    }, _this.getColorsFromSwatches = function (swatches, props) {\n      var colors = [];\n\n      for (var swatch in swatches) {\n        if (swatches.hasOwnProperty(swatch) && swatches[swatch]) {\n          if (props.rgb) {\n            colors.push(swatches[swatch].getRgb());\n          } else {\n            colors.push(swatches[swatch].getHex());\n          }\n        }\n      }\n\n      return colors;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  ColorExtractor.prototype.componentDidMount = function componentDidMount() {\n    this.processImage();\n  }; // If the src url is being passed by the parent component, and if it updates later then we need\n  // to parse the updated image again!\n\n\n  ColorExtractor.prototype.componentDidUpdate = function componentDidUpdate(props) {\n    // Check whether the src image or image element is new. If it's a new url, parse the image again!\n    if (props.src !== this.props.src && typeof this.props.src === 'string' && this.props.src.length > 0) {\n      this.parseImage(this.props.src, this.props);\n    } else if (this.props.children && // $FlowFixMe\n    props.children.props.src !== this.props.children.props.src) {\n      // $FlowFixMe\n      this.parseImage(this.props.children.props.src, this.props);\n    }\n  }; // Parse the image and extract the colors\n  // Get the array of colors from swatches\n\n\n  ColorExtractor.prototype.render = function render() {\n    var length = Children.count(this.props.children); // We don't handle multiple images at the moment or custom components, sorry!\n\n    if (length > 1) {\n      throw new Error('Expected only one image element.');\n    } else if (length === 1) {\n      // Children should be an image element\n      // $FlowFixMe\n      if (this.props.children.type === 'img') {\n        return this.props.children;\n      } else {\n        throw new Error('Expected children to be an image element but instead got a \"' + this.props.children.type + '\"');\n      }\n    } else {\n      return null;\n    }\n  };\n\n  return ColorExtractor;\n}(Component);\n\nColorExtractor.defaultProps = {\n  onError: function onError(error) {},\n  // Colors can be in vec3 format (rgb or hsl) or in hex format\n  getColors: function getColors(colors) {},\n  rgb: false,\n  hex: true,\n  src: null,\n  maxColors: 64\n};\nexport { ColorExtractor };","map":{"version":3,"sources":["/Users/yinjiezhang/Desktop/Final_Project/550_Final_project/code/gitrepo_550/WebApp_Gallery/client/node_modules/react-color-extractor/build/react-color-extractor.es.js"],"names":["Children","Component","Vibrant","classCallCheck","instance","Constructor","TypeError","inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","ColorExtractor","_React$Component","_temp","_this","_ret","_len","arguments","length","args","Array","_key","apply","concat","processImage","props","children","src","parseImage","console","error","image","from","maxColorCount","maxColors","getSwatches","then","swatches","getColors","getColorsFromSwatches","catch","useDefaultImageClass","DefaultOpts","ImageClass","load","data","onError","colors","swatch","hasOwnProperty","rgb","push","getRgb","getHex","componentDidMount","componentDidUpdate","render","count","Error","type","defaultProps","hex"],"mappings":"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","sourcesContent":["import { Children, Component } from 'react';\nimport Vibrant from 'node-vibrant';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n// This component takes a src prop (image source, can be a blob or an image path) or intercepts it's children to get the image element,\n// and parses the image using node-vibrant, and finally invokes the prop callback with an array of colors.\nvar ColorExtractor = function (_React$Component) {\n\tinherits(ColorExtractor, _React$Component);\n\n\tfunction ColorExtractor() {\n\t\tvar _temp, _this, _ret;\n\n\t\tclassCallCheck(this, ColorExtractor);\n\n\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\targs[_key] = arguments[_key];\n\t\t}\n\n\t\treturn _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.processImage = function () {\n\t\t\tif (_this.props.children) {\n\t\t\t\t// If the image element is direct children of ColorExtractor component, intercept the children and use the `src` property\n\t\t\t\t// $FlowFixMe\n\t\t\t\tif (_this.props.children.props.src) {\n\t\t\t\t\t_this.parseImage(_this.props.children.props.src, _this.props);\n\t\t\t\t}\n\t\t\t} else if (_this.props.src && typeof _this.props.src === 'string' && _this.props.src.length > 0) {\n\t\t\t\t// if the image is provided via src prop\n\t\t\t\t_this.parseImage(_this.props.src, _this.props);\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Please provide an image url using the 'src' prop or wrap an image element under the <ColorExtractor /> component. Check out the docs for more info - https://goo.gl/rMZ5L7\");\n\t\t\t}\n\t\t}, _this.parseImage = function (image, props) {\n\t\t\tVibrant.from(image).maxColorCount(props.maxColors).getSwatches().then(function (swatches) {\n\t\t\t\treturn props.getColors(_this.getColorsFromSwatches(swatches, props));\n\t\t\t}).catch(function (error) {\n\t\t\t\tif (error) {\n\t\t\t\t\t// This error is mainly due to CORS issue. So we retry again by using the default image class. But if still there is any error, we bail out!\n\t\t\t\t\t_this.useDefaultImageClass(image, props);\n\t\t\t\t}\n\t\t\t});\n\t\t}, _this.useDefaultImageClass = function (image, props) {\n\t\t\t// If there is any CORS issue, then the default class recreates the image element with crossOrigin set to anonymous.\n\t\t\tnew Vibrant.DefaultOpts.ImageClass()\n\t\t\t// $FlowFixMe\n\t\t\t.load(image.src).then(function (data) {\n\t\t\t\tif (data.image) {\n\t\t\t\t\tVibrant.from(data.image).getSwatches().then(function (swatches) {\n\t\t\t\t\t\treturn props.getColors(_this.getColorsFromSwatches(swatches, props));\n\t\t\t\t\t}).catch(function (error) {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tprops.onError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}).catch(function (error) {\n\t\t\t\tif (error) {\n\t\t\t\t\tprops.onError(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}, _this.getColorsFromSwatches = function (swatches, props) {\n\t\t\tvar colors = [];\n\n\t\t\tfor (var swatch in swatches) {\n\t\t\t\tif (swatches.hasOwnProperty(swatch) && swatches[swatch]) {\n\t\t\t\t\tif (props.rgb) {\n\t\t\t\t\t\tcolors.push(swatches[swatch].getRgb());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolors.push(swatches[swatch].getHex());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn colors;\n\t\t}, _temp), possibleConstructorReturn(_this, _ret);\n\t}\n\n\tColorExtractor.prototype.componentDidMount = function componentDidMount() {\n\t\tthis.processImage();\n\t};\n\n\t// If the src url is being passed by the parent component, and if it updates later then we need\n\t// to parse the updated image again!\n\n\n\tColorExtractor.prototype.componentDidUpdate = function componentDidUpdate(props) {\n\t\t// Check whether the src image or image element is new. If it's a new url, parse the image again!\n\n\t\tif (props.src !== this.props.src && typeof this.props.src === 'string' && this.props.src.length > 0) {\n\t\t\tthis.parseImage(this.props.src, this.props);\n\t\t} else if (this.props.children &&\n\t\t// $FlowFixMe\n\t\tprops.children.props.src !== this.props.children.props.src) {\n\t\t\t// $FlowFixMe\n\t\t\tthis.parseImage(this.props.children.props.src, this.props);\n\t\t}\n\t};\n\n\t// Parse the image and extract the colors\n\n\n\t// Get the array of colors from swatches\n\n\n\tColorExtractor.prototype.render = function render() {\n\t\tvar length = Children.count(this.props.children);\n\n\t\t// We don't handle multiple images at the moment or custom components, sorry!\n\t\tif (length > 1) {\n\t\t\tthrow new Error('Expected only one image element.');\n\t\t} else if (length === 1) {\n\t\t\t// Children should be an image element\n\t\t\t// $FlowFixMe\n\t\t\tif (this.props.children.type === 'img') {\n\t\t\t\treturn this.props.children;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Expected children to be an image element but instead got a \"' + this.props.children.type + '\"');\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\treturn ColorExtractor;\n}(Component);\n\nColorExtractor.defaultProps = {\n\tonError: function onError(error) {},\n\t// Colors can be in vec3 format (rgb or hsl) or in hex format\n\tgetColors: function getColors(colors) {},\n\trgb: false,\n\thex: true,\n\tsrc: null,\n\tmaxColors: 64\n};\n\nexport { ColorExtractor };\n"]},"metadata":{},"sourceType":"module"}